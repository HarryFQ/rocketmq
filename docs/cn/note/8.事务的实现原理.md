## [事务的实现原理](https://www.cnblogs.com/shanml/p/16584514.html)
### 1. 生产者发送事物消息
#### 1.1 生产者向broker 发送事物消息，事物消息中带有prepared 属性
1. 发送成功
   1. 通过事物监听器执行本地事物，并返回执行结果，记录本地事物执行的状态
1. 发送失败
   1. 本地事物状态进行回滚
#### 1.2 向broker发送结束事物的请求
1. 根据本地事物执行状态判断是提交还是回滚
   1. COMMIT_MSG: 表示提交事物
   2. ROLLBACK_MSG: 表示回滚事物
   3. UNKNOW: 表示事物执行结果位置状态
### 2. broker处理事物消息
#### 2.1 prepared 属性处理
1. 将消息写入half主题（`RMQ_SYS_TRANS_HALF_TOPIC` ）
#### 2.2 结束事物处理
1. 事物提交
   1. 从half 主题中删除消息
      1. 实际上放入另外一个OP队列中: `RMQ_SYS_TRANS_OP_HALF_TOPIC` 
      2. 将消息投送到原始主题中
2. 事物回滚
   1. 从half 主题中删除消息
      1. 实际上放入另外一个OP队列中: `RMQ_SYS_TRANS_OP_HALF_TOPIC` 
### 3. Broker 事物状态回查 
half主题下的所有队列进行处理(TransactionalMessageServiceImpl.check)
#### 3.1 获取half队列的消费进度，以及OP队列的消费进度
#### 3.2 从OP 队列中拉取消息用于判断事物是否已经处理完毕
#### 3.3 开启循环，处理half 消息
1. 如果循环的时间，超过每个队列处理的最大时间，终止循环，处理下一个队列
2. 如果OP队列中包含当前消息的偏移量，表示当前消息已被处理，也就是当前事物已经结束了，此时加入到已被处理的消息集合中。
3. 如果消息未被处理，获取half消息对象
   1. 消息获取为空
      1. 如果空，消息个数是否超过最大值，终止循环
      2. 判断拉取状态是否是NO_NEW_MSG
         1. 是。half队列中没有消息此时终止循环，等待下一次进行检查。
         2. 不是。表示消息的偏移量不合法，继续获取下一条消息进行处理。
   2. 消息获取不为空
      1. 是否需要丢弃当前消息或者跳过当前消息
         1. 根据half消息的检查次数是否大于最大限制来决定是否是否丢弃half消息(TransactionalMessageServiceImpl.needDiscard)
         2. 根据half消息在队列中的留存时间是否大于最大保留时间(72小时) 来决定是否跳过(TransactionalMessageServiceImpl.needSkip)
      2. 判断消息的添加时间是否大于等于本次检查的开始时间
         1. 说明是在检查之后加入的消息，暂不进行处理
      3. `PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS` 属性是否为空
         1. 否：判断half消息在队列流程时间是否小于事物最晚回查时间
            1. 是的话，检查half 消息在队列中的偏移量，决定是否将消息重新加入到half 主题中
         2. 是：判断消息的留存时间是否大于0，并且未超过事物的超时时间
            1. 如果是，则终止循环，暂不进行回查。
         4. 事物状态回查条件
            1. 从OP队列中拉取消息为空，并且当前half消息的留存时间已经大于事物设置的最晚回查时间
            2. 从OP队列中拉取消息不为空，并且拉取的最后一条消息的存入时间减去本次开始检查时间大于事物的超时时间
            3. half 消息在队列中的保留时间小于等于1，说明加入half消息的时间大于本次开始检查的时间
         5. 事物状态回查判断
            1. 需要回查
               1. 向生产者发送回查请求进行状态回查
            2. 不需要回查
               1. 继续从OP队列拉取消息判断是否已处理
         6. 偏移量加1，继续下一条
4. 更新half队列的消费进度
5. 更新OP队列的消费进度






















